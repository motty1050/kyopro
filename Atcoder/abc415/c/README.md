# ABC415 - Problem C

## 問題概要
<!-- 問題の概要を記載 -->
N 種類の薬品 
1,2,…,N があります。あなたの目標はこれらが全て混ざった状態にすることです。
0, 1 からなる長さ 
2 
N
 −1 の文字列 
S が与えられます。この文字列は次の情報を表します。

まず、 
1 種類以上の薬品が混ざった状態 
i ( 
1≤i≤2 
N
 −1 ) を次のように定義する。
i を 
2 進法で表記した際に下から 
k ( 
1≤k≤N ) 桁目が 
1 である、またその時に限り、薬品 
k が含まれている。
例えば、 
13 を 
2 進法で表記すると 
1101 
(2)
​
  となるため、状態 
13 は薬品 
1,3,4 が混ざった状態を表現します。
S の 
i 文字目が 0 であるとき、状態 
i は 安全 である。
S の 
i 文字目が 1 であるとき、状態 
i は 危険 である。
あなたは次の操作を使って薬品を混ぜ合わせます。

まず、空の瓶を用意する。
次に、以下を繰り返す。
まだ瓶に注いでいない薬品を 
1 種類選択し、瓶に注ぐ。
この時、瓶の中で混ざった薬品が危険な状態であってはならない。
この操作によって全ての薬品が混ざった状態を作れるか判定してください。

T 個のテストケースが与えられるので、それぞれについて答えを求めてください。
## 制約
<!-- 制約を記載 -->
T は 
1 以上 
40000 以下の整数
N は 
1 以上 
18 以下の整数
S は 0, 1 からなる長さ 
2 
N
 −1 の文字列
ひとつの入力に含まれる 
∣S∣=2 
N
 −1 の総和は 
5×10 
5
  を超えない

## サンプル
<!-- サンプル入出力を記載 -->
入力
5
3
0010000
3
0010110
1
1
2
100
4
001110010101110
出力
Yes
No
No
Yes
Yes

## 解法
<!-- 解法のアイデアを記載 -->

### アルゴリズム概要
**動的プログラミング（ビットDP）**を使用して、各状態から安全に到達可能かを判定

### 問題の理解
1. **状態の表現**: 状態iを2進法で表記した時、k桁目が1なら薬品kが含まれる
   - 例: 状態13 = 1101₂ → 薬品1,3,4が混ざった状態
2. **安全性**: S[i-1]が'0'なら状態iは安全、'1'なら危険
3. **操作**: 空瓶から始めて薬品を1つずつ追加、危険な状態を経由してはいけない

### DPの設計
- **dp[mask]**: mask状態を安全に作れるかを表すブール値
- **初期状態**: dp[0] = True（空の瓶は安全）
- **遷移**: 現在の状態maskから薬品addを追加してnmaskになる時
  - nmask = mask | (1 << add)
  - S[nmask-1] == '0'なら安全 → dp[nmask] = True

### 詳細手順
1. **初期化**: dp[0] = True、他はFalse
2. **状態遷移**: 全ての状態maskについて
   - dp[mask] == Falseなら無視
   - 含まれていない薬品addを追加
   - 新状態nmaskが安全なら dp[nmask] = True
3. **判定**: dp[(1<<N)-1]がTrueなら"Yes"、Falseなら"No"

### 時間計算量
- **O(N × 2^N)**: 各状態に対してN個の薬品を試す
- N≤18なので最大でも約4.7×10^6回の計算

### トレース例

#### テストケース1: N=3, S="0010000"

**状態と安全性:**
```
状態1(001): 薬品[1] → 安全
状態2(010): 薬品[2] → 安全  
状態3(011): 薬品[1,2] → 危険
状態4(100): 薬品[3] → 安全
状態5(101): 薬品[1,3] → 安全
状態6(110): 薬品[2,3] → 安全
状態7(111): 薬品[1,2,3] → 安全
```

**DP遷移:**
```
dp[0] = True (初期状態)
mask=0 → 薬品1,2,3を追加可能 → dp[1]=dp[2]=dp[4]=True
mask=1 → 薬品3追加可能(状態3は危険) → dp[5]=True  
mask=2 → 薬品3追加可能(状態3は危険) → dp[6]=True
mask=4 → 薬品1,2追加可能 → dp[5]=dp[6]=True
mask=5 → 薬品2追加可能 → dp[7]=True
mask=6 → 薬品1追加可能 → dp[7]=True
```

**結果**: dp[7] = True → "Yes"

#### テストケース2: N=3, S="0010110"

**危険な状態:**
```
状態3(011): 薬品[1,2] → 危険
状態5(101): 薬品[1,3] → 危険  
状態6(110): 薬品[2,3] → 危険
```

**問題**: どの2つの薬品の組み合わせも危険
→ 3つ全てを混ぜることは不可能

**結果**: "No"

### 実装のポイント
1. **ビット演算**: 状態をビットマスクで効率的に管理
2. **1-indexed対応**: S[nmask-1]でアクセス（状態番号は1から）
3. **高速入力**: sys.stdin.readlineで大量テストケースに対応

### エッジケース
- **N=1**: 薬品1つだけの場合
- **全て安全**: 全ての中間状態が安全な場合
- **全て危険**: 薬品を1つでも混ぜると危険な場合

### 実装コード
```python
def main():
    T = int(input())
    for _ in range(T):
        N = int(input())
        S = input().strip()
        dp = [False] * (1 << N)
        dp[0] = True
        
        for mask in range(1 << N):
            if not dp[mask]:
                continue
            for add in range(N):
                if not (mask & (1 << add)):
                    nmask = mask | (1 << add)
                    if S[nmask - 1] == '0':
                        dp[nmask] = True
        
        print("Yes" if dp[(1 << N) - 1] else "No")
```

### 視覚的解説（N=3の場合）

#### 状態の遷移グラフ
```
        000 (空瓶)
       / | \
      /  |  \
   001  010  100
    |    |    |
   101  110  (危険な組み合わせをスキップ)
    \    /
     \  /
      111 (全薬品)
```

#### ビットマスクの対応
```
状態番号 | 2進表記 | 含まれる薬品 | 安全性
---------|---------|-------------|-------
1        | 001     | [1]         | S[0]
2        | 010     | [2]         | S[1]  
3        | 011     | [1,2]       | S[2]
4        | 100     | [3]         | S[3]
5        | 101     | [1,3]       | S[4]
6        | 110     | [2,3]       | S[5]
7        | 111     | [1,2,3]     | S[6]
```

## 実装日時
2025-07-30 13:55:32
