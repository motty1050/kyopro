# ABC415 - Problem B
https://atcoder.jp/contests/abc415/tasks/abc415_b
## 問題概要
<!-- 問題の概要を記載 -->
一直線状の倉庫があります。この倉庫に 偶数個 の荷物が保管されています。
倉庫の情報は文字列 
S として与えらます。
倉庫は区画 
1,2,…,∣S∣ の 
∣S∣ 個の区画からなり、 
S の各文字は以下の情報を表します。

S の 
i 文字目が # であるとき、区画 
i に荷物が 
1 つ置かれている。
S の 
i 文字目が . であるとき、区画 
i に荷物が置かれていない。
この倉庫にはロボットがあり、このロボットは以下の行動を倉庫から荷物が無くなるまで繰り返します。

荷物をその荷物がある区画番号の小さい方から 
2 つ回収する。回収された荷物は倉庫の外へ運び出される。
繰り返しの各回で運び出された 
2 つの荷物が倉庫のどの区画にあったものかを求めてください。
## 制約
<!-- 制約を記載 -->
S は # と . からなる長さ 
2 以上 
1000 以下の文字列
倉庫には偶数個の荷物が保管されている
倉庫には 
2 つ以上の荷物が保管されている

## サンプル
<!-- サンプル入出力を記載 -->
入力
.#.##..##.#.###....#
出力
倉庫に保管されている荷物の総数を 
m とすると、 
m/2 行出力せよ。
そのうち 
i 行目には、 
i 回目の繰り返しで運び出された荷物が元々あった区画の番号を小さい方から順に カンマ区切り で出力せよ。
2,4
5,8
9,11
13,14
15,20

## 解法
<!-- 解法のアイデアを記載 -->

### アルゴリズム概要
1. 文字列Sを左から右にスキャンして、'#'（荷物）がある位置を全て記録
2. 記録した位置を2つずつペアにして出力

### 詳細手順
1. **入力処理**: 文字列Sを読み込む
2. **位置の特定**: 文字列を1文字ずつ確認し、'#'がある位置（1-indexed）をリストに保存
3. **ペア出力**: リストの要素を先頭から2つずつ取り出してカンマ区切りで出力

### 時間計算量
- **O(|S|)**: 文字列を1回スキャンするだけ
- 荷物の個数をmとすると、出力はm/2行

### トレース例

#### 入力: `.#.##..##.#.###....#`

**Step 1: 位置の特定**
```
インデックス: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
文字列     : . # . # # . . # # . #  .  #  #  #  .  .  .  .  #
区画番号   : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
```

'#'がある区画番号を記録:
- インデックス1 → 区画2
- インデックス3 → 区画4  
- インデックス4 → 区画5
- インデックス7 → 区画8
- インデックス8 → 区画9
- インデックス10 → 区画11
- インデックス12 → 区画13
- インデックス13 → 区画14
- インデックス14 → 区画15
- インデックス19 → 区画20

**positions = [2, 4, 5, 8, 9, 11, 13, 14, 15, 20]**

**Step 2: ペア出力**
```
1回目: positions[0], positions[1] → 2,4
2回目: positions[2], positions[3] → 5,8  
3回目: positions[4], positions[5] → 9,11
4回目: positions[6], positions[7] → 13,14
5回目: positions[8], positions[9] → 15,20
```

#### 期待される出力:
```
2,4
5,8
9,11
13,14
15,20
```

### 実装のポイント
- **1-indexed**: 区画番号は1から始まるため、`i + 1`で調整
- **リスト内包表記**: Pythonらしい簡潔な書き方
- **ペア処理**: `range(0, len(positions), 2)`で2つずつ処理

### エッジケース
- **最小ケース**: `##` → `1,2`
- **偶数保証**: 問題の制約により、必ず偶数個の荷物が存在

### アルゴリズムの流れ図
```
入力: .#.##..##.#.###....#
         ↓
1. 文字列をスキャン
         ↓
2. '#'の位置を記録: [2, 4, 5, 8, 9, 11, 13, 14, 15, 20]
         ↓
3. 2つずつペアにして出力:
   (2,4) → 2,4
   (5,8) → 5,8
   (9,11) → 9,11
   (13,14) → 13,14
   (15,20) → 15,20
```

### 実装コード
```python
def main():
    s = input()
    positions = [i + 1 for i, c in enumerate(s) if c == '#']
    for i in range(0, len(positions), 2):
        print(f"{positions[i]},{positions[i+1]}")
```
## 実装日時
2025-07-30 13:53:22
